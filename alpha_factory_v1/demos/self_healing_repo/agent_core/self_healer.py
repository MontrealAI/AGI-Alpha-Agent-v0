# SPDX-License-Identifier: Apache-2.0
# self_healer.py
import os
import shutil
import subprocess

from . import diff_utils, llm_client, test_runner

class SelfHealer:
    def __init__(self, repo_url: str, commit_sha: str, base_branch: str = "main"):
        self.repo_url = repo_url
        self.commit_sha = commit_sha
        self.base_branch = base_branch
        self.working_dir = "/tmp/self_heal_run"  # ephemeral work dir
        self.test_results = None
        self.error_log = None
        self.patch_diff = None

    def setup_repo(self):
        """Clone the repo at the specific commit into a clean working directory."""
        if os.path.exists(self.working_dir):
            shutil.rmtree(self.working_dir)
        os.makedirs(self.working_dir, exist_ok=True)
        subprocess.run(["git", "clone", "--no-checkout", self.repo_url, "."], cwd=self.working_dir, check=True)
        subprocess.run(["git", "checkout", self.commit_sha], cwd=self.working_dir, check=True)
        # Optionally, install dependencies if needed (pip install, etc).
        # This could be inferred from requirements.txt or other config.

    def run_tests_collect_error(self):
        """Run the test suite and collect output if failures occur."""
        runner = test_runner.get_default_runner(self.working_dir)
        success, output = runner.run_tests()
        self.test_results = output
        if success:
            return True  # All tests passed
        # On failure, isolate the failing part of output (last traceback, etc.)
        self.error_log = runner.extract_failure_log(output)
        return False

    def analyze_and_propose_fix(self):
        """Analyze error_log and get an LLM-proposed diff."""
        if not self.error_log:
            raise RuntimeError("No error log to analyze")
        # Prepare prompt for LLM â€“ include error message and relevant code context
        prompt = llm_client.build_prompt(self.error_log, code_dir=self.working_dir)
        # Request a diff from LLM
        diff_response = llm_client.request_patch(prompt)
        # Validate that response is a unified diff
        self.patch_diff = diff_utils.parse_and_validate_diff(diff_response)
        return self.patch_diff is not None

    def apply_patch(self):
        """Apply the proposed diff to the working directory."""
        if not self.patch_diff:
            raise RuntimeError("No patch to apply")
        success = diff_utils.apply_diff(self.patch_diff, repo_dir=self.working_dir)
        return success

    def commit_and_push_fix(self):
        """Commit the changes to a new branch and push to remote."""
        branch_name = f"auto-fix/{llm_client.generate_branch_name(self.error_log)}"
        subprocess.run(["git", "checkout", "-b", branch_name], cwd=self.working_dir, check=True)
        subprocess.run(["git", "add", "."], cwd=self.working_dir, check=True)
        commit_msg = f"Auto-fix: {llm_client.summarize_error(self.error_log)} [ci skip]"
        subprocess.run(["git", "commit", "-m", commit_msg], cwd=self.working_dir, check=True)
        # Use provided token for auth (set in env for git)
        subprocess.run(["git", "push", "origin", branch_name], cwd=self.working_dir, check=True)
        return branch_name

    def create_pull_request(self, branch_name: str):
        """Open a GitHub Pull Request for the new branch."""
        repo_owner = os.getenv("GITHUB_REPOSITORY_OWNER")  # e.g. from env in CI
        repo_name = os.getenv("GITHUB_REPOSITORY_NAME")
        gh_token = os.getenv("GITHUB_TOKEN")
        title = f"[Self-Heal] Fix for failing test: {llm_client.summarize_error(self.error_log)}"
        body = "This PR was automatically generated by the self-healing CI agent.\n"
        body += f"Failed Run: commit {self.commit_sha}\n"
        body += "Error Log:\n```\n" + (self.error_log[:500] or "") + "\n```\n"  # include snippet
        body += "\nProposed Fix Diff:\n```diff\n" + (self.patch_diff[:300] or "") + "\n```\n"
        body += "\nPlease review the changes. If approved, this will close the failing issue."
        # Use GitHub API to create PR
        import af_requests as requests
        url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/pulls"
        headers = {"Authorization": f"Bearer {gh_token}"}
        json_data = {
            "title": title,
            "head": branch_name,
            "base": self.base_branch,
            "body": body
        }
        response = requests.post(url, headers=headers, json=json_data)
        response.raise_for_status()
        pr_number = response.json().get("number")
        return pr_number

    def run(self):
        """Execute the full self-healing pipeline."""
        self.setup_repo()
        if self.run_tests_collect_error():
            print("No failure detected, nothing to fix.")
            return None
        print("Test failed, error log captured. Analyzing...")
        self.analyze_and_propose_fix()
        if not self.patch_diff:
            print("LLM did not return a valid patch. Aborting auto-fix.")
            return None
        print("Patch received. Applying patch...")
        if not self.apply_patch():
            print("Failed to apply patch. Aborting.")
            return None
        print("Patch applied. Re-running tests for verification...")
        if not self.run_tests_collect_error():
            # If still failing after patch, we could iterate or abort.
            print("Patch did not fix the issue. Consider manual intervention.")
            # (Optional) Could attempt another LLM iteration here.
            return None
        print("Tests passed after patch! Preparing to commit and push fix...")
        branch = self.commit_and_push_fix()
        pr = self.create_pull_request(branch)
        print(f"Opened Pull Request #{pr} for the fix.")
        return pr
